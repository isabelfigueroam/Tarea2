{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p>Este proyecto usa el metodo de cuadratura Gaussiana para integrar funciones en un intervalo finito. Especificamente, se encuentra una aproximacion para la solucion de la integral definida en el intervalo [1, 3] de la funcion \\(x^6-x^2sen(2x)\\). Se incluye la implementacion del c\u00f3digo de Python en el archivo 'cuadrature.py', con su documentaci\u00f3n publicada en esta pagina web utilizando MkDocs.</p>"},{"location":"explanation/","title":"M\u00e9todo Num\u00e9rico: Cuadratura Gauss-Legendre","text":"<p>La cuadratura Gaussiana es un m\u00e9todo num\u00e9rico para aproximar integrales definidas de la forma:</p> \\[ \\int_{a}^{b} f(x)\\,dx \\approx \\sum_{i=1}^{N} w_i\\, f(x_i) \\] <p>donde:</p> <ul> <li>\\(x_i\\) son los puntos de colocaci\u00f3n.</li> <li>\\(w_i\\) son los pesos asociados a cada punto.</li> <li>\\(N\\) es el orden de la cuadratura (la cantidad de puntos utilizados).</li> </ul> <p>A diferencia de otros m\u00e9todos vistos en el curso como trapezoides o Simpson, que usan puntos equiespaciados, la cuadratura gaussiana elige los puntos \\(x_i\\) de manera mas \u00f3ptima, para maximizar la precisi\u00f3n con el menor n\u00famero de evaluaciones de la funci\u00f3n.</p> <p>En el caso de Gauss-Legendre, los puntos \\(x_i\\) se eligen como las ra\u00edces del polinomio de Legendre \\(P_N(x)\\), definido por la relaci\u00f3n de recurrencia:</p> \\[ (n+1)P_{n+1}(x) = (2n+1)x\\,P_n(x) - n\\,P_{n-1}(x), \\quad P_0(x)=1,\\quad P_1(x)=x \\] <p>Los pesos correspondientes est\u00e1n dados por:</p> \\[ w_i = \\frac{2}{\\left(1 - x_i^2\\right)\\left[P_N'(x_i)\\right]^2} \\] <p>La cuadratura Gauss-Legendre de orden \\(N\\) integra exactamente cualquier polinomio de grado \u2264 \\(2N - 1\\).</p> <p>Por ejemplo, con N = 3, se puede integrar exactamente cualquier polinomio de hasta grado 5, sin error.</p> <p>Este m\u00e9todo tiene la ventaja de ser r\u00e1pido, preciso y sistem\u00e1tico. Con solo aumentar \\(N\\) mejora la aproximaci\u00f3n hasta que el resultado se estabiliza dentro de una tolerancia requerida. En la pr\u00e1ctica, se calcula con varios valores de N y se elige el primero que alcanza la convergencia (como se muestra en la secci\u00f3n Tutorial de uso).</p>"},{"location":"reference/","title":"Documentaci\u00f3n","text":""},{"location":"reference/#cuadrature","title":"<code>cuadrature</code>","text":""},{"location":"reference/#cuadrature.funcIntegrando","title":"<code>funcIntegrando(x)</code>","text":"<p>Define la funci\u00f3n integrando para el problema planteado:</p> <pre><code>f(x) = x^6 - x^2 * sin(2x)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or ndarray</code> <p>Valor o arreglo de valores donde se eval\u00faa f(x).</p> required <p>Returns:</p> Type Description <p>float or numpy.ndarray: Resultado de evaluar la funci\u00f3n.</p> Example <p>funcIntegrando(1.0) 0.09070257317431829</p>"},{"location":"reference/#cuadrature.gaussxw","title":"<code>gaussxw(N)</code>","text":"<p>Calcula los puntos y pesos de la cuadratura de Gauss-Legendre en el intervalo est\u00e1ndar [-1, 1].</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>N\u00famero de puntos de cuadratura.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(x, w) - x (numpy.ndarray): Puntos de colocaci\u00f3n. - w (numpy.ndarray): Pesos asociados.</p> Example <p>x, w = gaussxw(3) len(x), len(w) (3, 3)</p>"},{"location":"reference/#cuadrature.gaussxwab","title":"<code>gaussxwab(a, b, x, w)</code>","text":"<p>Escala los puntos y pesos de la cuadratura de Gauss-Legendre desde [-1, 1] hasta un intervalo arbitrario [a, b].</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Extremo inferior del intervalo.</p> required <code>b</code> <code>float</code> <p>Extremo superior del intervalo.</p> required <code>x</code> <code>ndarray</code> <p>Puntos en [-1, 1].</p> required <code>w</code> <code>ndarray</code> <p>Pesos en [-1, 1].</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(x_scaled, w_scaled) - x_scaled (numpy.ndarray): Puntos escalados a [a, b]. - w_scaled (numpy.ndarray): Pesos ajustados a [a, b].</p> Example <p>x, w = gaussxw(2) xs, ws = gaussxwab(1, 3, x, w) len(xs), len(ws) (2, 2)</p>"},{"location":"reference/#cuadrature.integrar_gauss","title":"<code>integrar_gauss(a, b, N)</code>","text":"<p>Calcula la integral de la funci\u00f3n definida en <code>funcIntegrando(x)</code> usando cuadratura de Gauss-Legendre con N puntos.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>L\u00edmite inferior de integraci\u00f3n.</p> required <code>b</code> <code>float</code> <p>L\u00edmite superior de integraci\u00f3n.</p> required <code>N</code> <code>int</code> <p>N\u00famero de puntos de cuadratura.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Aproximaci\u00f3n de la integral en [a, b].</p> Example <p>integrar_gauss(1, 3, 4) 2.639399999999999  # resultado aproximado</p> Notes <ul> <li>Para probar la convergencia, puede compararse este valor con el obtenido   usando un N mucho mayor (ej. N=20).  </li> <li>A medida que se incrementa N, la aproximaci\u00f3n converge al valor de referencia.  </li> <li>El valor \u201ccorrecto\u201d en este contexto se identifica como aquel en que   el resultado deja de cambiar en las cifras significativas.</li> </ul>"},{"location":"tutorials/","title":"Tutorial de uso","text":"<p>Este m\u00f3dulo permite calcular la integral</p> \\[ \\int_{1}^{3} \\left(x^6 - x^2\\sin(2x)\\right)\\,dx \\] <p>usando cuadratura Gauss-Legendre. A continuaci\u00f3n se muestra un ejemplo completo de uso.</p>"},{"location":"tutorials/#ejemplo","title":"Ejemplo","text":"<p>Este ejemplo recorre valores de N hasta que dos aproximaciones consecutivas difieren menos de <code>1e-6</code> (el valor de tolerancia).</p> <pre><code>from cuadrature import integrar_gauss\n\na, b = 1.0, 3.0\ntol = 1e-6\n\nN = 1\nprev = None\n\nwhile True:\nI_N = integrar_gauss(a, b, N)\nif prev is not None:\ndiff = abs(I_N - prev)\nprint(f\"N={N:2d} | I={I_N:.12f} | |\u0394|={diff:.2e}\")\nif diff &lt; tol:\nprint(f\"\\nConvergencia alcanzada con N = {N}\")\nbreak\nelse:\nprint(f\"N={N:2d} | I={I_N:.12f} | |\u0394|=n/a\")\nprev = I_N\nN += 1\n</code></pre> <p>Salida:</p> <pre><code>N= 1 | I=134.054419962463 | |\u0394|=n/a\nN= 2 | I=306.819934495920 | |\u0394|=1.73e+02\nN= 3 | I=317.264151733829 | |\u0394|=1.04e+01\nN= 4 | I=317.345390334158 | |\u0394|=8.24e-03\nN= 5 | I=317.344226721970 | |\u0394|=1.16e-03\nN= 6 | I=317.344246889996 | |\u0394|=2.02e-05\nN= 7 | I=317.344246672227 | |\u0394|=2.18e-07\n\nConvergencia alcanzada con N = 7\n</code></pre>"},{"location":"tutorials/#que-tan-grande-debe-ser-n","title":"\u00bfQu\u00e9 tan grande debe ser N?","text":"<p>En Gauss\u2013Legendre, un orden N integra exactamente polinomios de grado \u2264 (2N \u2212 1). Aqu\u00ed el integrando tiene una parte polin\u00f3mica <code>$x^6$</code> y una parte no polin\u00f3mica <code>$\u2212x^2\u00b7sin(2x)$</code>. Por eso el error no se anula con un N finito, pero decrece r\u00e1pidamente al aumentar N. Entonces, buscamos un N tal que cumpla la tolerancia requerida por el problema.</p>"}]}